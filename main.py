import os
from pathlib import Path
import tkinter as tk
from tkinter import ttk, filedialog, messagebox

import numpy as np
import h5py
import segyio
import matplotlib
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt


# ---------------------------
# SEG-Y writer (方案一：segyio)
# ---------------------------
def write_segy_segyio(out_path: str, data_2d: np.ndarray, dt_s: float, trace_major: bool = True):
    """
    out_path: output .segy
    data_2d: 2D numpy array
        - if trace_major=True:  (n_traces, n_samples)
        - else:                 (n_samples, n_traces)
    dt_s: sampling interval (seconds)
    """
    if data_2d.ndim != 2:
        raise ValueError(f"Only 2D dataset supported. Got shape={data_2d.shape}")

    if trace_major:
        n_traces, n_samples = data_2d.shape
        traces = data_2d
    else:
        n_samples, n_traces = data_2d.shape
        traces = data_2d.T

    dt_us = int(round(dt_s * 1_000_000))
    if dt_us <= 0:
        raise ValueError(f"Invalid dt_s={dt_s}")

    # SEG-Y spec
    spec = segyio.spec()
    sorting_none = (
        getattr(segyio.TraceSortingFormat, "NONE", None)
        or getattr(segyio.TraceSortingFormat, "UNDEFINED", None)
        or getattr(segyio.TraceSortingFormat, "UNKNOWN", None)
        or 0
    )
    spec.sorting = sorting_none
    spec.format = 5  # IEEE float32
    spec.samples = np.arange(n_samples) * dt_s
    spec.tracecount = n_traces

    out_path = str(Path(out_path).expanduser())

    with segyio.create(out_path, spec) as f:
        # text header
        text = {
            1: "GENERATED BY h5_to_segy_gui.py",
            2: "FORMAT=5 IEEE FLOAT32",
            3: f"NS={n_samples} DT(us)={dt_us}",
            4: "MINIMAL HEADERS",
        }
        f.text[0] = segyio.tools.create_text_header(text)

        # binary header
        f.bin[segyio.BinField.Interval] = dt_us
        f.bin[segyio.BinField.Samples] = n_samples
        f.bin[segyio.BinField.Format] = 5

        # traces + trace headers
        for i in range(n_traces):
            f.trace[i] = np.asarray(traces[i], dtype=np.float32)

            hdr = f.header[i]
            hdr[segyio.TraceField.TRACE_SEQUENCE_LINE] = i + 1
            hdr[segyio.TraceField.TRACE_SEQUENCE_FILE] = i + 1
            hdr[segyio.TraceField.TRACE_SAMPLE_COUNT] = int(n_samples)
            hdr[segyio.TraceField.TRACE_SAMPLE_INTERVAL] = int(dt_us)

            # 2D/3D fields (minimal)
            hdr[segyio.TraceField.INLINE_3D] = 1
            hdr[segyio.TraceField.CROSSLINE_3D] = i + 1

        f.flush()


# ---------------------------
# HDF5 helpers
# ---------------------------
def list_h5_datasets(h5_path: str):
    """
    Return a list of dataset paths inside the H5 file.
    e.g. ['/data', '/group1/dsetA', ...]
    """
    paths = []
    with h5py.File(h5_path, "r") as f:
        def visitor(name, obj):
            if isinstance(obj, h5py.Dataset):
                paths.append("/" + name if not name.startswith("/") else name)

        f.visititems(visitor)
    return paths


def read_h5_dataset(h5_path: str, dset_path: str):
    """
    Read dataset into memory as numpy array.
    """
    with h5py.File(h5_path, "r") as f:
        if dset_path.startswith("/"):
            key = dset_path[1:]
        else:
            key = dset_path
        if key not in f:
            # try direct access
            dset = f[dset_path]
        else:
            dset = f[key]
        arr = dset[()]  # load into memory
    return np.asarray(arr)


def read_febus(filename: str):
    """
    Read FEBUS H5 file and return data + metadata.
    Expected path: /<group>/Source1/Zone1/(Strain Rate [nStrain|s] or StrainRate)
    """
    with h5py.File(filename, "r") as f:
        zone1 = None
        strain_rate = None

        for a in f:
            # tolerate both "/{a}//Source1/Zone1" and "/{a}/Source1/Zone1"
            base_candidates = [f"/{a}//Source1/Zone1", f"/{a}/Source1/Zone1"]
            base = next((p for p in base_candidates if p in f), None)
            if base is None:
                continue

            zone1 = f[base]
            if "Strain Rate [nStrain|s]" in zone1:
                strain_rate = zone1["Strain Rate [nStrain|s]"][:]
                break
            if "StrainRate" in zone1:
                strain_rate = zone1["StrainRate"][:]
                break

        if zone1 is None or strain_rate is None:
            raise ValueError(
                "FEBUS: 未找到 /<group>/Source1/Zone1/Strain Rate [nStrain|s] 或 StrainRate"
            )

        dx = zone1.attrs["Spacing"][0]
        dt = zone1.attrs["Spacing"][1] * 1e-3

        nb, nt, nx = strain_rate.shape
        data = np.nan_to_num(
            strain_rate[:, nt // 2 :, :].reshape(-1, nx),
            nan=0.0,
            posinf=0.0,
            neginf=0.0,
        )
        nt, nx = data.shape

        gauge_length = zone1.attrs["GaugeLength"][:][0]
        ampli_power = zone1.attrs["AmpliPower"][:]
        pulse_width = zone1.attrs["PulseWidth"][:]
        fiber_length = zone1.attrs["FiberLength"][:]

    fname = str(Path(filename).stem)

    metadata = {
        "fs": 1 / dt,
        "dt": dt,
        "dx": dx,
        "nx": nx,
        "nt": nt,
        "gauge_length": gauge_length,
        "ampli_power": ampli_power,
        "pulse_width": pulse_width,
        "fiber_length": fiber_length,
        "source_name": fname,
    }

    return data, metadata


def read_segy_matrix_raw(path: str, max_traces: int | None, max_samples: int | None):
    """
    Minimal SEG-Y reader (big-endian) for plotting.
    Only supports format code 5 (IEEE float32).
    """
    import struct

    with open(path, "rb") as f:
        f.seek(0, 2)
        file_size = f.tell()
        if file_size < 3600:
            raise ValueError("文件太小，不是有效 SEG-Y")

        # Binary header
        f.seek(3200)
        bh = f.read(400)
        dt_us = struct.unpack(">H", bh[16:18])[0]
        nsamples = struct.unpack(">H", bh[20:22])[0]
        fmt = struct.unpack(">H", bh[24:26])[0]

        if nsamples <= 0:
            raise ValueError("SEG-Y 二进制头中 Samples=0")
        if fmt != 5:
            raise ValueError(f"不支持的格式码: {fmt}（目前只支持 5=IEEE float32）")

        bytes_per_sample = 4
        trace_size = 240 + nsamples * bytes_per_sample
        data_bytes = file_size - 3600
        n_traces = data_bytes // trace_size
        if n_traces <= 0:
            raise ValueError(
                f"SEG-Y 文件没有 trace（仅有 3600 字节头）。请重新转换或确认输出文件。size={file_size}"
            )

        trace_idx = np.arange(n_traces)
        sample_idx = np.arange(nsamples)
        if max_traces and n_traces > max_traces:
            trace_idx = np.linspace(0, n_traces - 1, max_traces).astype(int)
        if max_samples and nsamples > max_samples:
            sample_idx = np.linspace(0, nsamples - 1, max_samples).astype(int)

        data = np.empty((len(trace_idx), len(sample_idx)), dtype=np.float32)
        for i, ti in enumerate(trace_idx):
            offset = 3600 + ti * trace_size + 240
            f.seek(offset)
            tr = np.fromfile(f, dtype=">f4", count=nsamples)
            if tr.size != nsamples:
                raise ValueError("读取 trace 数据失败（长度不足）")
            data[i, :] = tr[sample_idx]

    dt_s = (dt_us / 1_000_000.0) if dt_us else None
    return data, dt_s, trace_idx, sample_idx


def read_segy_matrix(path: str, max_traces: int | None, max_samples: int | None):
    try:
        with segyio.open(path, "r", ignore_geometry=True, strict=False) as f:
            n_traces = f.tracecount
            n_samples = len(f.samples)

            if n_traces == 0:
                raise ValueError("SEG-Y 文件没有 trace（tracecount=0），无法绘图")

            trace_idx = np.arange(n_traces)
            sample_idx = np.arange(n_samples)

            if max_traces and n_traces > max_traces:
                trace_idx = np.linspace(0, n_traces - 1, max_traces).astype(int)
            if max_samples and n_samples > max_samples:
                sample_idx = np.linspace(0, n_samples - 1, max_samples).astype(int)

            data = np.empty((len(trace_idx), len(sample_idx)), dtype=np.float32)
            for i, ti in enumerate(trace_idx):
                tr = np.asarray(f.trace[ti], dtype=np.float32)
                data[i, :] = tr[sample_idx]

            dt_us = f.bin[segyio.BinField.Interval] if segyio.BinField.Interval in f.bin else None
            dt_s = (dt_us / 1_000_000.0) if dt_us else None

        return data, dt_s, trace_idx, sample_idx
    except Exception:
        return read_segy_matrix_raw(path, max_traces, max_samples)


def plot_segy(data: np.ndarray, dt_s: float | None, title: str, parent: tk.Tk):
    fig, ax = plt.subplots(figsize=(12, 6), dpi=120)
    im = ax.imshow(
        data.T,
        cmap="seismic",
        aspect="auto",
        origin="upper",
        interpolation="nearest",
    )
    ax.set_xlabel("Trace index")
    if dt_s:
        n_samples = data.shape[1]
        t_max = (n_samples - 1) * dt_s
        ax.set_ylabel(f"Time (s), 0..{t_max:.3f}")
    else:
        ax.set_ylabel("Sample index")
    ax.set_title(title)
    fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04, label="Amplitude")
    fig.tight_layout()

    win = tk.Toplevel(parent)
    win.title(title)
    win.geometry("1100x700")
    canvas = FigureCanvasTkAgg(fig, master=win)
    canvas.draw()
    canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)


# ---------------------------
# GUI
# ---------------------------
class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("H5 → SEG-Y Converter (segyio)")
        self.geometry("1100x650")

        self.folder = None
        self.h5_files = []          # list[Path]
        self.selected_h5 = None     # Path
        self.dataset_paths = []     # list[str]
        self.selected_dataset = tk.StringVar(value="")

        # config variables
        self.dt_var = tk.StringVar(value="0.001")  # seconds
        self.trace_major_var = tk.BooleanVar(value=True)  # True: (n_traces, n_samples)

        self.out_dir = None

        self._build_ui()

    def _build_ui(self):
        # Top toolbar
        top = ttk.Frame(self, padding=8)
        top.pack(side=tk.TOP, fill=tk.X)

        btn_open = ttk.Button(top, text="打开文件夹（扫描 H5）", command=self.choose_folder)
        btn_open.pack(side=tk.LEFT)

        btn_out = ttk.Button(top, text="选择输出目录", command=self.choose_out_dir)
        btn_out.pack(side=tk.LEFT, padx=(8, 0))

        self.folder_label = ttk.Label(top, text="未选择文件夹")
        self.folder_label.pack(side=tk.LEFT, padx=(12, 0))

        self.out_label = ttk.Label(top, text="输出：默认同目录")
        self.out_label.pack(side=tk.LEFT, padx=(12, 0))

        # Main area: left (file list) / right (details)
        main = ttk.Frame(self, padding=8)
        main.pack(side=tk.TOP, fill=tk.BOTH, expand=True)

        # Left: h5 list
        left = ttk.Frame(main)
        left.pack(side=tk.LEFT, fill=tk.BOTH, expand=False)

        ttk.Label(left, text="H5 文件列表").pack(anchor="w")

        self.file_list = tk.Listbox(left, width=45, height=25)
        self.file_list.pack(fill=tk.BOTH, expand=True)
        self.file_list.bind("<<ListboxSelect>>", self.on_select_file)

        # Middle-right: dataset list + preview + settings
        right = ttk.Frame(main)
        right.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(12, 0))

        # Dataset selector
        ds_row = ttk.Frame(right)
        ds_row.pack(fill=tk.X)

        ttk.Label(ds_row, text="Dataset：").pack(side=tk.LEFT)
        self.ds_combo = ttk.Combobox(ds_row, textvariable=self.selected_dataset, values=[], state="readonly", width=70)
        self.ds_combo.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.ds_combo.bind("<<ComboboxSelected>>", self.on_select_dataset)

        # Info / preview
        info = ttk.LabelFrame(right, text="信息 / 预览", padding=8)
        info.pack(fill=tk.BOTH, expand=True, pady=(10, 0))

        self.info_text = tk.Text(info, height=15, wrap="word")
        self.info_text.pack(fill=tk.BOTH, expand=True)

        # Settings
        cfg = ttk.LabelFrame(right, text="转换设置", padding=8)
        cfg.pack(fill=tk.X, pady=(10, 0))

        row1 = ttk.Frame(cfg)
        row1.pack(fill=tk.X, pady=2)
        ttk.Label(row1, text="dt (秒，自动读取)：").pack(side=tk.LEFT)
        ttk.Entry(row1, textvariable=self.dt_var, width=12, state="readonly").pack(side=tk.LEFT, padx=(6, 16))

        self.chk_trace_major = ttk.Checkbutton(
            row1,
            text="数据形状是 (n_traces, n_samples)  [不勾选则认为是 (n_samples, n_traces)]",
            variable=self.trace_major_var
        )
        self.chk_trace_major.pack(side=tk.LEFT, fill=tk.X, expand=True)

        # Convert button
        row2 = ttk.Frame(cfg)
        row2.pack(fill=tk.X, pady=(8, 0))

        self.btn_convert = ttk.Button(row2, text="转换为 SEG-Y", command=self.convert_current)
        self.btn_convert.pack(side=tk.LEFT)

        self.btn_convert_all = ttk.Button(row2, text="转换所有文件", command=self.convert_all)
        self.btn_convert_all.pack(side=tk.LEFT, padx=(8, 0))

        self.btn_plot = ttk.Button(row2, text="绘制 SEG-Y", command=self.plot_current_segy)
        self.btn_plot.pack(side=tk.LEFT, padx=(8, 0))

        self.progress = ttk.Progressbar(row2, mode="indeterminate")
        self.progress.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(10, 0))

    def log(self, s: str):
        self.info_text.insert(tk.END, s + "\n")
        self.info_text.see(tk.END)

    def clear_log(self):
        self.info_text.delete("1.0", tk.END)

    def choose_folder(self):
        folder = filedialog.askdirectory(title="选择包含 H5 文件的文件夹")
        if not folder:
            return

        self.folder = Path(folder)
        self.folder_label.config(text=f"文件夹：{self.folder}")

        self.scan_h5_files()

    def choose_out_dir(self):
        out = filedialog.askdirectory(title="选择输出 SEG-Y 的目录（可选）")
        if not out:
            self.out_dir = None
            self.out_label.config(text="输出：默认同目录")
            return
        self.out_dir = Path(out)
        self.out_label.config(text=f"输出：{self.out_dir}")

    def scan_h5_files(self):
        self.h5_files = []
        self.file_list.delete(0, tk.END)
        self.clear_log()

        if self.folder is None:
            return

        # scan .h5 / .hdf5
        files = sorted(list(self.folder.glob("*.h5")) + list(self.folder.glob("*.hdf5")))
        self.h5_files = files

        for p in self.h5_files:
            self.file_list.insert(tk.END, p.name)

        self.log(f"扫描到 {len(self.h5_files)} 个 H5 文件。")
        if len(self.h5_files) == 0:
            self.log("提示：该目录下没有 .h5/.hdf5 文件。")

        # clear dataset UI
        self.ds_combo["values"] = []
        self.selected_dataset.set("")
        self.selected_h5 = None
        self.dataset_paths = []

    def on_select_file(self, event=None):
        sel = self.file_list.curselection()
        if not sel:
            return

        idx = sel[0]
        self.selected_h5 = self.h5_files[idx]
        self.clear_log()
        self.log(f"选择文件：{self.selected_h5}")

        # list datasets
        try:
            self.progress.start(10)
            self.update_idletasks()

            dsets = list_h5_datasets(str(self.selected_h5))
            self.dataset_paths = dsets
            self.ds_combo["values"] = dsets

            if dsets:
                self.selected_dataset.set(dsets[0])
                self.log(f"发现 {len(dsets)} 个 dataset。已默认选择：{dsets[0]}")
                self.show_dataset_info(dsets[0])
            else:
                self.selected_dataset.set("")
                self.log("未发现任何 dataset（该 H5 可能只包含 group，或者是空文件）。")

        except Exception as e:
            messagebox.showerror("读取失败", f"读取 H5 dataset 列表失败：\n{e}")
            self.log(f"[ERROR] {e}")
        finally:
            self.progress.stop()

    def on_select_dataset(self, event=None):
        dset = self.selected_dataset.get()
        if not dset:
            return
        self.show_dataset_info(dset)

    def show_dataset_info(self, dset_path: str):
        if self.selected_h5 is None:
            return
        try:
            self.progress.start(10)
            self.update_idletasks()

            with h5py.File(str(self.selected_h5), "r") as f:
                key = dset_path[1:] if dset_path.startswith("/") else dset_path
                dset = f[key] if key in f else f[dset_path]

                shape = dset.shape
                dtype = dset.dtype

                self.log(f"Dataset: {dset_path}")
                self.log(f"  shape: {shape}")
                self.log(f"  dtype: {dtype}")

                # show some attrs
                if len(dset.attrs) > 0:
                    self.log("  attrs:")
                    for k in list(dset.attrs.keys())[:30]:
                        v = dset.attrs[k]
                        # short-print
                        v_str = str(v)
                        if len(v_str) > 120:
                            v_str = v_str[:120] + "..."
                        self.log(f"    - {k}: {v_str}")
                else:
                    self.log("  attrs: (none)")

                # quick preview (first few samples of first trace)
                if len(shape) == 2:
                    # load small slice only
                    # note: h5py supports slicing without loading full dataset
                    n0 = min(5, shape[0])
                    n1 = min(10, shape[1])
                    preview = dset[:n0, :n1]
                    self.log("  preview (top-left corner):")
                    self.log(str(preview))
                else:
                    self.log("  提示：该 dataset 不是 2D，GUI 目前只支持 2D 转换。")

        except Exception as e:
            messagebox.showerror("预览失败", f"读取 dataset 信息失败：\n{e}")
            self.log(f"[ERROR] {e}")
        finally:
            self.progress.stop()

    def convert_current(self):
        if self.selected_h5 is None:
            messagebox.showwarning("提示", "请先选择一个 H5 文件。")
            return

        trace_major = bool(self.trace_major_var.get())

        # output path
        out_dir = self.out_dir if self.out_dir is not None else self.selected_h5.parent
        out_name = self.selected_h5.stem + ".segy"
        out_path = out_dir / out_name

        # run convert
        try:
            self.progress.start(10)
            self.update_idletasks()

            self.log("")
            self.log("开始读取数据到内存...")
            arr, metadata = read_febus(str(self.selected_h5))
            arr = np.asarray(arr)

            dt_s = float(metadata["dt"])
            self.dt_var.set(f"{dt_s:g}")

            if arr.ndim != 2:
                raise ValueError(f"Only 2D dataset supported. Got ndim={arr.ndim}, shape={arr.shape}")

            self.log(f"读取完成：shape={arr.shape}, dtype={arr.dtype}")
            self.log(f"FEBUS dt={dt_s} 秒 (从文件读取)")
            self.log(f"FEBUS dx={metadata.get('dx')}, nx={metadata.get('nx')}, nt={metadata.get('nt')}")

            self.log("开始写 SEG-Y...")
            write_segy_segyio(str(out_path), arr, dt_s=dt_s, trace_major=trace_major)

            self.log(f"转换完成 ✅ 输出：{out_path}")
            messagebox.showinfo("成功", f"转换完成！\n输出文件：\n{out_path}")

        except Exception as e:
            messagebox.showerror("转换失败", f"转换失败：\n{e}")
            self.log(f"[ERROR] {e}")
        finally:
            self.progress.stop()

    def convert_all(self):
        if not self.h5_files:
            messagebox.showwarning("提示", "当前没有可转换的 H5 文件。")
            return

        out_dir = self.out_dir if self.out_dir is not None else self.folder
        if out_dir is None:
            messagebox.showwarning("提示", "请先选择包含 H5 文件的文件夹。")
            return

        failed = []
        success = 0

        try:
            self.progress.start(10)
            self.update_idletasks()

            self.log("")
            self.log(f"开始批量转换，共 {len(self.h5_files)} 个文件...")

            for p in self.h5_files:
                try:
                    self.log(f"读取：{p}")
                    arr, metadata = read_febus(str(p))
                    arr = np.asarray(arr)

                    dt_s = float(metadata["dt"])
                    if arr.ndim != 2:
                        raise ValueError(f"Only 2D dataset supported. Got ndim={arr.ndim}, shape={arr.shape}")

                    out_path = out_dir / (p.stem + ".segy")
                    self.log(f"写入：{out_path}")
                    write_segy_segyio(str(out_path), arr, dt_s=dt_s, trace_major=bool(self.trace_major_var.get()))
                    success += 1
                except Exception as e:
                    failed.append((p.name, str(e)))
                    self.log(f"[ERROR] {p.name}: {e}")

            self.log(f"批量转换完成：成功 {success}，失败 {len(failed)}")

        finally:
            self.progress.stop()

        if failed:
            msg = "以下文件转换失败：\n" + "\n".join([f"{name}: {err}" for name, err in failed[:20]])
            if len(failed) > 20:
                msg += f"\n... 还有 {len(failed) - 20} 个失败"
            messagebox.showwarning("批量转换完成（有失败）", msg)
        else:
            messagebox.showinfo("批量转换完成", f"全部成功，共 {success} 个文件。")

    def plot_current_segy(self):
        if self.selected_h5 is None:
            messagebox.showwarning("提示", "请先选择一个 H5 文件。")
            return

        out_dir = self.out_dir if self.out_dir is not None else self.selected_h5.parent
        out_name = self.selected_h5.stem + ".segy"
        segy_path = out_dir / out_name

        if not segy_path.exists():
            messagebox.showwarning("提示", f"未找到 SEG-Y 文件：\n{segy_path}\n请先转换。")
            return

        try:
            self.progress.start(10)
            self.update_idletasks()

            data, dt_s, trace_idx, sample_idx = read_segy_matrix(
                str(segy_path), max_traces=1000, max_samples=2000
            )
            title = f"{segy_path.name}  (traces={len(trace_idx)}, samples={len(sample_idx)})"
            plot_segy(data, dt_s, title, self)
        except Exception as e:
            messagebox.showerror("绘图失败", f"绘图失败：\n{e}")
            self.log(f"[ERROR] {e}")
        finally:
            self.progress.stop()


if __name__ == "__main__":
    app = App()
    app.mainloop()
